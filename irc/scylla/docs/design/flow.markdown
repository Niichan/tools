Scylla Flow
===========

protocol line >>= mechanism >>= event >>= core >>= policy >>= action >>= 
mechanism >>= protocol line

#### Protocol Line

A line from a client or another server. Depending on the mechanism the encoding 
or format of this can vary. This is fed to a mechanism to produce an event for 
the core.

Examples:

- `:420 KILL 649AAABAD :Bad nickname`
- `PRIVMSG #foo :bar baz`
- `@account=Xena :420AAAABS PRIVMSG #foo :bar baz`

Support for message tags will be a core feature.

#### Event

An incoming event from a client or server that needs to have a policy applied 
to it. This is made up of:

- Source UUID
- Event verb
- Arguments as strings
- A list of the message tags
- Any additional metadata
  - `OPMOD` information, etc
  - `ENCAP` targets, etc
  - `OVERRIDE` flag to make event skip policy checks
- A list of the actions generated by previous policy checks (if any)

#### Action

An outgoing event. This is made up of:

- Source of a message
- Target of a message:
  - Channel
    - everyone in a channel that matches a condition
  - Another client
    - all clients that match a condition
    - all clients
  - Server
    - everyone on a server that matches a condition
    - all servers
  - All ircops
    - all ircops that match a condition (snote masks, etc)
- Message verb
- Arguments as strings
- Message metadata
- A boolean value indicating if the message should be broadcast or not.

When the core gets to the end of policy evaluation on an event it will take the 
list of actions and alert each mechanism of the incoming action. In the case 
that the target of a message is not an individual client or every client on the 
server, the core will dispatch messages to mechanisms by evaluating the 
condition.

These conditions will be simple and not policy-based.

#### Mechanism

Middleware that turns protocol lines into events and actions into protocol 
lines. These will be things like server links and client connections.

In the case of remote server links, remote servers will be implicitly trusted 
and allowed to do whatever network state changes they like.

#### Policy

Middleware that takes an event and returns it and one or more actions or 
rejects the event and returns one or more actions describing the reason behind 
the rejection.

As policies will come from either Scylla core developers or the users of the 
daemon, policies must have a level defining when it should be processed.

User policies will be processed first, these will be for things like custom 
additions for the network or other little things.

Extra policies will defaultly define the behavior of the Elemental-IRCd 
extensions to the base RFC 1459 protocol or support for additional client 
capabilities.

RFC policies will define the policies dictated by RFC 1459.

Fallback policies will define the "fallback" behavior, such as allowing 
PRIVMSG/NOTICE lines to go through and adding the "shell" layers around a WHOIS 
request.

```go
type Level int

const (
    LevelUserPolicy Level = iota
    LevelExtraPolicy
    LevelRFCPolicy
    LevelFallbackPolicy
)

type IDer interface {
    ID() (id string)
}

type Verber interface {
    Verb() (verb string)
}

type Checker interface {
    Check(e Event) (continue bool, ret []Action)
}

type Leveler interface {
    Level() (l Level)
}

type Policy interface {
    IDer
    Verber
    Checker
    Leveler
}
```

Policies must append their actions to the slice of actions. If `continue` is 
set to `false`, then no more policies will be applied to the message and the 
actions will be sent out as needed. It is considered an error to have
`len(ret) == 0`.

#### Policy Servers

Policy servers contain a set of policies that must not change at runtime. If 
a policy server wants to redeclare its policies, it should restart.

When registering, a policy server must send a list of the Verb-UUID pairs of 
policies that it has.

```go
type RegistrationMessage struct {
    Password   string    // Passed as an environment variable, a random value
    Policies   []Policy  // The list of policies
    SocketPath string    // Path to the socket the server is listening on
}
```

When registered, a policy will subscribe to an event verb. Policy server 
implementations should not send an event to a policy that doesn't listen for 
that event verb. Additionally the core will send an event to the policy server 
by the policy UUID to make things easier. Policy servers should not apply any 
policy but the one requested to the event sent to it.

Policy servers must open a domain socket at `var/somename.sock`. Policy servers 
may query the core for network information via HTTP requests at 
`var/core.sock`.

#### Core

Takes in events, sends out actions to the correct mechanisms. The core will 
implicitly convert events that can't match to a policy to an error action 
describing the command not being able to be found.

The core will also need to keep track of channel and user data. It must contain 
a mapping of all network clients to the mechanism they are connected via. It 
must also have a list of all policy servers connected to it as well as the 
socket paths for sending a message to them.

As the core will keep track of this data, it will expose a simple REST-ful JSON 
API via a domain socket for policy servers to perform lookups on network state 
to better inform their decisions. This service **must not** allow a policy 
server to make changes to network state. Policies that must change network 
state (killing a client for example) **must** return that as an action from 
a policy check.
